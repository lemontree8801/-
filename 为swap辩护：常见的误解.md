- [原文链接](https://chrisdown.name/2018/01/02/in-defence-of-swap.html)


# 为swap辩护：常见的误解
摘要：
- 1.有swap是一个运行良好的系统相当重要的一部分。没有它，理智的内存管理就更难实现。
- 2.swap通常不是为了获得紧急内存，而是为了内存回收变得平等和有效。事实上，把它当作“紧急内存”通常是有害的。
- 3.禁用swap并不会防止磁盘I/O成为内存争用的问题，它只是将磁盘I/O抖动从匿名页到文件页。这不仅会降低效率，因为我们可以从更小的页面池中选择要回收的页，而且还可能导致首先进入这种高争用状态。
- 4.4.0之前的内核上swapper有很多陷阱，并且由于它过于急于swap，导致了很多人对swap负面的看法。在内核4.0之后，这种情况要好得多。
- 5.在SSD上，交换匿名页和回收文件页在性能/延时方面基本上是等价的。在机械盘上，由于随机读取，所以swap读取较慢，因此`vm.swappiness`设置在这里是有意义的。
- 6.禁用swap并不能防止临近OOM时的病态行为，尽管使用swap确实会延长它。无论系统全局OOM killer是在有或没有swap情况下调用的，还是在早或晚情况下调用的，结果都是一样的：系统处于不可预测的状态。没有swap也不能避免这种情况。
- 7.您可以使用`memory.low`和cgroup v2的friends在内存压力下实现更好的swap行为和组织抖动。


----------
作为我改进内核内存管理和`cgroup v2`工作的一部分，我已经与许多工程师讨论了对内存管理的attitudes，特别是在压力下的应用程序行为和内存管理底层使用的操作系统启发法。

在这些讨论中反复出现的话题是swap。swap是一个备受争议的话题，但人们对它的了解却很少，即使是那些多年来一直使用Linux的人也是如此。许多人认为它是无用的或有害的：它是内存稀缺的时代的遗留物，磁盘是提供急需的分页空间的必要工具。这个话题近年来我仍然看到它相对频频出现，并且我与同事，朋友和行业同仁进行了许多讨论，以帮助他们理解为什么在可用内存比过去大的现代计算机上swap仍然是一个有用的概念，并且具有更多的意义。

关于swap的目的还存在很多误解——许多人只是将其视为紧急情况下使用的一种“缓慢的额外内存”，但不了解它在正常负载下如何对整个操作系统整体的健康操作的贡献。

我们中的许多人都听过大多数有关内存的常见用法：“Linux使用太多内存”，“swap空间应为物理内存大小的两倍”等。尽管这些微不足道的东西很难消除，或者围绕它们的讨论近年来变得更加细致，但是swap“无用”论更多的是基于启发法和深奥的知识，而不是可以用简单的类比来解释的东西，是更需要了解内存管理的原因。

这篇文章主要是针对那些管理Linux系统的人，并且有兴趣听一听运行在swap较小或者没有swap亦或是`vm.swappiness`设置为0。

## 背景
如果对Linux内存管理中一些基本底层机制没有共同的理解，就很难讨论为什么在正常操作中有swap或者换出是一件好事，所以让我们先达成一致。

### 内存类型
Linux中有许多不同类型的内存，每种类型都有自己的属性。理解其中细微差别是理解为什么swap很重要的关键。

例如，页（内存中的“块”，通常是4K）负责保存在计算机上运行的每个进程的代码。还有一些页负责缓存与这些程序访问的文件相关的数据和元数据，以加快将来的访问速度。这些是页缓存的一部分，我将它们称为文件内存。

还有一些页负责在代码中进行内存分配，例如，当使用malloc分配的新内存被写入时，或者使用`mmap`的`MAP_ANONYMOUS`标志时。这些都是“匿名”页——之所以这么叫是因为它们没有任何后台——我倾向称它们为匿名内存。

也还有其他类型的内存——共享内存、块内存、内核堆栈内存、缓冲区等等——但是匿名内存和文件内存是最为人熟知和容易理解的，所以我将使用这些在我的例子中，虽然它们也同样适用于这些类型。

### 可回收/不可回收内存
当考虑一种特定类型的内存时，最基本的问题之一是它能否被回收。这里的“回收”意味着系统在可以不丢失数据的情况下，从物理内存中清除这种类型的页。

对某些类型的页，这通常是微不足道的。例如，干净页（未修改），我们只是为了性能而缓存磁盘上的某些东西，因此我们可以删除页而不需要执行任何操作。

对某些类型的页，这是可能的，但不是微不足道的。例如脏页（修改），我们不能直接删除页，因为磁盘还没有我们的修改。因此，我们要么拒绝回收，要么在删除内存之前将更改落盘。

对某些类型的页，这是不可能的。例如，在前面提到的匿名页，它们只存在内存中，不存在其他备份存储中，因此必须将它们保存在内存中。

## 关于swap的本质
如果您查找关于Linux上swap的用途的描述，您将不可避免地发现许多人谈论它，好像它仅仅是用于紧急情况的物理内存的扩展。例如，下面是我在谷歌中输入“what is swap”后得到的一个随机帖子：

>swap本质上是紧急内存；当您的系统临时需要的物理内存比内存中可用内存多时，所留出的空间。它被认为是“坏的”，因为它速度慢、效率低，如果您的系统经常需要使用swap，那么它显然没有足够的内存。[....]如果您有足够的内存来处理所有的需求，并且不希望将其最大化，那么在没有swap空间的情况下运行应该是完全安全的。

需要澄清的是，我对这些评论的发布者的帖子内容一无所知——许多Linux管理员将其视为“常识”，并且可能是您如果与他们谈论swap的话，将听到的最有可能的事情之一，但是，不幸的是，这也是对swap的目的和用途的误解，尤其是在现代系统上。

在上面，我谈到“不可能”进行匿名页的回收，因为从内存中清除匿名页时，匿名页的本质没有备份存储可以返回——因此，它们的回收将导致这些页的数据丢失。但是，如果我们可以为这些页创建这样一个存储会怎么样呢？

这正是swap的目的。Swap是一个存储区域，用于存储这些看起来“不可回收”的页，允许我们根据需要将页换出到存储设备。这意味着，它们现在可以被认为与更容易回收的页（比如干净的文件页）一样有资格回收，从而更有效地利用可用的物理内存。

**Swap主要是一种等同于回收的机制，而不是紧急的“额外内存”。Swap不是使应用程序变慢的原因——进入整体内存争用是使应用程序变慢的原因。**

那么，在这种“等同回收”的情况下，我们在什么情况下会合理地选择回收匿名页呢？以下是一些常见的场景：
- 1.在初始化期间，长时间运行的程序可能会分配和使用多个页。这些页也可以用作关机/清理的一部分，但是一旦程序“启动”就不需要了（从特定于应用程序的角度来看）。对于需要初始化依赖项的守护程序，这是相当常见的。
- 2.在程序正常运行时，我们可以分配少量使用的内存。对于整个系统性能来说，更合理的做法是需要一个major fault来按需从磁盘换入页，而不是将内存用于其他更重要的任务。

## 在有swap/无swap的情况下检查发生了什么
让我们看看典型的情况，以及在有无swap的情况下它们的性能。我在有关cgroup v2的讨论中谈到了有关“内存争用”的指标。

### 在没有或者低内存争用的情况下
- **有swap**：我们可以选择换出很少使用的匿名内存，这些内存可能只在进程生命周期的一小部分中使用，从而允许我们使用这些内存来提高缓存命中率，或者进行其他优化。
- **无swap**：我们不能换出很少使用的匿名内存，因为它被锁定在内存中。虽然这可能不会立即成为一个问题，但在某些负载上，这可能是由于陈旧的匿名页占用了更重要的使用空间而导致性能显著下降。

### 在中等/高内存争用的情况下
- **有swap**：所有的内存类型都有相同的回收可能性。这意味着我们有更多的机会可以成功回收页——也就是说，我们可以回收那些不会很快出现faulted back的页（抖动）
- **无swap**：匿名页被锁定在内存中，因为它们无处可去。成功的长期页回收的可能性比较低，因为我们只有一些类型的内存可以回收。页抖动的风险更高。一般读者可能认为这样做会更好，因为这样做可以避免磁盘I/O，但这不是真的——我们只是将swap的磁盘I/O转移到删除热页缓存和删除我们很快需要的代码段。

### 在内存使用的临时峰值下
- **有swap**：我们对临时性的峰值更有弹性，但是在内存严重不足的情况下，从内存抖动到OOM杀死的时间可能会延长。我们对引起内存压力的程序有更多的了解，可以更合理地对它们采取行动，并可以进行控制干预。
- **没有swap**：当匿名页被锁定到内存中并不能被回收时，OOM会被更快地触发。我们更可能在内存上发生抖动，但是抖动和OOM的时间缩短了。根据您的应用程序，这可能更好也可能更糟。例如，基于队列的应用程序可能希望快速从内存抖动到OOM。也就是说，这对于真正有用仍然太迟了——只在严重饥饿的时候调用OOM，当内存争用一开始就杀死，这种方法更好。

### 好的，我想要系统swap，但是我怎样才能针对不同的应用程序调优呢？
需要引入cgroup v2。

显然，通用启发式算法很难一直准确，因此能够指导内核是很重要的。过去您只能在系统层调整`vm.swappiness`。这有2个问题：`vm.swappiness`难以推理，因为它仅作为较大启发式系统的一小部分，而且它是系统级的范围，而不是粒度更小的进程。

您还可以使用`mlock`将页锁定在内存中，但这需要修改程序代码，使用`LD_PRELOAD`函数，或者在运行时使用调试器。基于VM语言，这表现也不佳，因为您通常无法控制分配，最终不得不用`mlockall`，这没有精准到您关心的页。

cgroup v2以`memory.low`的形式提供了一个可调整的每个cgroup，它允许我们告诉内核选择哪些应用程序回收低于一定阈值的内存。这使得我们在内存争用时不用阻止内核换出我们应用程序的某些部分，而是希望从其他应用程序回收。在正常情况下，内核swap逻辑通常非常好，允许它适时换出页通常可以提高系统性能。在内存严重争用时swap抖动不是很理想，但它更多的是完全耗尽内存，而不是swapper的问题。在这种情况下，当内存压力开始增加时，您通常希望通过自身关闭一些非关键的进程。

您不能简单地依赖于OOM。当我们已经进入系统严重不健康的并且可能已经存在一段时间的严重状态时，那么只会在严重失败的情况下调用OOM。在调用OOM之前，您需要有机会自己处理。

但是使用传统的Linux内存计数器来确定内存压力有点困难。我们有一些看起来有点相关的东西，但是仅仅是切题的——内存使用，页扫描数量等——仅从这些指标很难将有效的内存配置于趋于内存争用的配置分辨开。在Facebook里，有一组人由Johannes牵头，致力于开发新的指标，以更轻松地揭示内存压力，这将在将来有所帮助。如果您有兴趣了解更多有关此信息，那么我将在[cgroup v2的讨论中详细介绍这个指标](https://youtu.be/ikZ8_mRotT4?t=2145)。

## 优化
### 那么我应该有多大的swap？
通常，最佳内存管理所需的最小swap空间取决于固定在内存中的应用程序很少访问的匿名页的数量，以及回收这些匿名页的价值。后者主要是一个问题，即哪些页不再被清除以取代这些不常访问的匿名页。

如果您有大量的磁盘空间和最新的（4.0+）内核，那么swap空间越大越好。在旧版本内核中，`kswapd`是负责管理swap的内核进程之一，在过去总是迫切地希望换出更多的内存。最近，当大量swap空间可用时，swap行为得到了显著的改善。如果您正在使用4.0+内核，在现代内核上进行较大的swap应该不会导致过度的swap。因此，如果您有足够的空间，那么可以在4.0内核上使用几个GB的swap大小。

如果您的磁盘空间有限，那么答案实际上取决于您必须作出的权衡和环境的性质。理想情况下，您应该有足够的swap，使您的系统在正常和峰值（内存）负载下均能最佳运行。我的建议是设置具有2-3GB或者更多swap空间的测试系统，并监视在不同（内存）负载条件下一周左右的时间内发生的情况。只要您在那一周没有遇到严重内存不足（在这种情况下，测试将不会很有用），您最终可能占用几百MB的swap空间。这样，除了为更改负载提供一点缓冲之外，至少值得拥有足够多的swap空间。`atop`在`SWAPSZ`列以日志模式记录了哪些应用程序正在将页换出，因此如果您还没有在您的服务器上使用它来记录历史服务器状态，那么希望您在这些测试机器上使用日志模式来设置它，作为这个实验的一部分。这还会告诉您应用程序何时开始换出页，您可以将这些与日志事件或其他关键数据联系起来。

另一个值得考虑的事情是swap介质的性质。Swap的读取往往是高度随机的，因为我们无法可靠地预测哪些页面在何时refaulted。在SSD上这并不重要，但是在机械盘上，随机I/O非常昂贵，因为它需要物理移动才能实现。另一方面，文件页的refault可能不那么随机，因为在单个应用程序运行时操作的相关联的文件碎片较少，因此重新整理文件页的可能性较小。这意味着在机械盘上，您可能希望更倾向于回收文件页，而不是换出匿名页。你需要再次测试和评估如何平衡负载。

对想要使用swap的笔记本电脑用户和台式机用户，也需要考虑这一点——在这种情况下，您的swap文件至少应该是物理内存大小。

### `swappiness`应该如何设置？
首先，了解`vm.swappiness`是什么很重要。`vm.swappiness`是一种是内存回收偏向于回收匿名页或文件页的系统。它使用两个不同属性来实现这一点：`file_prio`（回收文件页的意愿）和`anon_prio`（回收匿名页的意愿）。`vm.swappiness`是`anon_prio`的默认值，`file_prio`的默认值是用200相减。这意味着，如果`vm.swappiness`设置为50，结果是`anon_prio`为50，`file_prio`为150（确切的数字与相对权重来比无关紧要）。

通常，这意味着**`vm.swappiness`只是回收和refaulting匿名内存与文件内存的比率**。值越低，内核就会认为不经常访问的匿名页在硬件上换出和换入的代价很高。值越高，内核就会认为在硬件上swap匿名页和文件页的代价是相似的。内存管理子系统仍然主要根据内存的热度来决定是swap文件页还是匿名页，但是`swappiness`提示成本计算要么更倾向于swap，要么更倾向于丢弃文件系统缓存，因为它可以采用任何一种方式。在SSD上，它们基本是一样昂贵的，所以设置`vm.swappiness=100`（完全相等）可能性能很好。在机械盘上，swap可能要昂贵的多，因为swap通常要随机读取，所以您可能希望更倾向于较低的值。

事实上，大多数人并不真正知道他们的硬件需求，所以仅仅根据直觉来调整这个值并不是一件简单的事情——您需要使用不同的值来测试它。您还可以花时间评估系统和核心应用程序的内存组成，以及它们在轻度内存回收下的行为。

当谈到`vm.swappiness`时，需要考虑是的[2012年 Satoru Moriya 对vmscan的极其重大的更改](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=fe35004fbf9eaf67482b074a2e032abb9c89b1dd)，该更改极大改变了`vm.swappiness=0`的处理方式。

从本质上说，这个补丁当`vm.swappiness=0`时，偏向于根本不使用扫描（并回收）任何匿名页，除非我们已经遇到了严重的内存争用。如本文前面所述，这通常不是您想要的，因为这可以防止出现极端内存压力之前先进行回收，这实际上可能首先导致这种极端内存压力。`vm.swappiness=1`是您在不调用该补丁中实现的用于匿名页扫描的特殊情况下所能达到的最低值。

内核默认的是`vm.swappiness=60`。这个值对大多数负载来说通常不是太坏，但是很难有一个通用的默认值来适用所有负载。因此，在“我需要多少swap空间”部分中提到的调优的一个有价值的事是使用不同的`vm.swappiness`测试这些系统，并在繁重的（内存）负载下监视您的应用程序和系统指标。在不久的将来，一旦我们在内核中有了一个不错的refault检测实现，您就可以通过查看cgroup v2的页面refaulting指标来确定某种负载。

## 总结
- Swap是一种有用的工具，它允许平等地回收内存页，但是它的用途经常被误解，导致整个行业对它的负面看法。但是，如果您按预期的想法使用swap——作为一种增加回收平等的方法——您会发现它是一个有用的工具，而不是一个障碍。
- 禁用swap在内存争用的情况下不会防止磁盘I/O成为问题，它只是将磁盘I/O抖动从匿名页转移到文件页。这不仅会降低效率，因为我们可以从更小的页面池中选择要回收的页，而且一开始它也可能有助于进入这种高竞争状态。
- Swap使系统更不容易OOM，因为它提供了另一种更慢的内存来源，以便在内存不足的情况下调用——OOM只被内核用作最后的手段，在内存严重不足的时候使用。这里的解决方案取决于您的系统：
	- 您可以根据 cgroup-local或全局内存压力来适时更改负载。这从一开始就避免了出现这些情况，但是在Unix的整个历史中都缺乏可靠的内存压力指标。希望随着refault的检测，这种情况会很快得到改善。
	- 您可以使用`memory.low`对每个cgroup的某些进程进行倾斜回收（并因此进行swap），允许您在不完全禁用swap的情况下保护关键守护进程。
